\chapter{Background}
\label{chap:background}
This chapter covers background information discussed in this dissertation. We assume that the reader has basic familiarity with \textit{Blockchain} and \textit{Ethereum} concepts and we explain the more detailed aspects of Ethereum Virtual Machine (EVM), Ethereum infrastructure, and Decentralized Applications running on top of Ethereum. 

%what is opcode?!

\section{Dig deeper into Ethereum}
Smart contracts are pieces of codes that are deployed to a blockchain systems, to remove the barrier of trusting middleman and to run specific logic. Ethereum is the first and mostly used public blockchain that introduced rich smart contracts that are not just limited to some specific scripts (like Bitcoin scripting language). Smart contracts are supposed to be immutable and tamper proof which means the code cannot be changed just after deployment to the blockchain.

Smart contracts (in Ethereum) are usually written in High-Level programming languages such as Solidity and Vyper and compiled into a Low-Level EVM bytecodes using a compiler (\eg Solc). An EVM bytecode is a binary string that is interpretable by EVM. Then EVM bytecode will be deployed to the Ethereum main blockchain.

To understand the process of deployment of a smart contract one should have familiarity with different types of accounts in Ethereum. There are two types of Ethereum accounts: \textit{Externally Owned Account (EOA)} and \textit{Contract Account}. 
EOA is an account that is controlled by a private key and keeps balance of Ethers that the account has and also a \textit{nonce}, which indicates the number of transactions sent by the account and act like a counter to mitigate replay attacks. Any external actor can generate a random private key and use ECDSA encryption algorithm to generate the public key from the private key. Ethereum uses SECP-256k1 curve for ECDSA as described in the Ethereum yellow paper.
The EOA addresses can create new transactions, sign them with the private key related to the account and send it to Ethereum network to be confirmed and recorded on the main Ethereum chain. This transaction can:
\begin{enumerate}
    \item Send Ether to another EOA.
    \item Create a new \textit{Contract Account} by sending a bytecode.
    \item Calling a \textit{Contract Account} to execute a logic.
\end{enumerate}

Each transaction type is explained below:

\paragraph{Sending Ether.} 
For sending Ether into another EOA account the sender should specify the address which should be an EOA and not a contract account and also an amount to be sent.

\paragraph{Creating a new Contract Account.}
Creating a new \textit{Contract Account} is a bit tricky. The EOA should send a transaction containing the bytecode of the contract and setting the destination address to \emph{null}. Then EVM will create an address for the newly generated contract. The newly generated account (which is a contract account) keeps four fields: A \textit{nonce} which is similar to nonce in EOA and keeps track of number of transactions created by that account, Ether balance which indicates number of Ether the account holds, \textit{Contract Code} which keeps the bytecode of the account which is executed each time a transaction calls the account, and \textit{Contract Storage} which is a Merkle Patricia Tree data structure that maintain the data related to the contract account. Detailed explanation of the contract storage can be found in Section \textblue{refer}. 
The other important aspect of contract creation in Ethereum is how EVM generate the address for newly generated contract account. In EOA contract creation, EVM calculates the contract address by using the transaction sender's address and it's nonce. The formula is show below:
\begin{equation}
    \label{eqn:create}
    Address = keccak256(rlp.encode(deployingAddress, nonce))[12:]
\end{equation}

In addition, contract accounts also can create a new contract account using two different EVM opcodes: \texttt{Create} and \texttt{Create2}. For transactions originated by a contract account and consist of these two opcodes, EVM will deterministically calculate the address for the new account and then create a contract account with the related four fields explained above. The whole process of contract creation is similar for these two opcodes, but the main difference is how EVM calculates the address for the contract account. For \texttt{Create} opcode the calculation formula is the same as formula EVM uses for EOA contract creation (Formula~\ref{eqn:create}).\footnote{Here the nonce is the nonce of contract account.} But, for \texttt{Create2} opcode, EVM uses completely different formula to calculate it. In this type EVM calculates the address by using sender's address and bytecode that is sent to be deployed (a.k.a init code). Because the formula does not contain nonce and all other variables are predictable, the newly generated address in this type is \emph{Predictable}. The formula for contract address calculations using \texttt{Create2} is:

\begin{equation}
    \label{eqn:create2}
    Address = keccak256(0xff + senderAddress + salt + keccak256(init-code))[12:]    
\end{equation}

Based on the formula~\ref{eqn:create2}, if the same sender address, tries to deploy the same initialization code, the address will be the same. But, EVM does not permit to redeploy a contract if there is still a contract account related to that address. But, there is a way to delete the previous contract account and then re-deploy the contract on the same address. If the contract contains \texttt{SELFDESTRUCT} opcode, by calling it the whole contract account along with it's four field will be wiped out and so there is a chance to re-deploy the contract. The whole process is explained in detail in Chapter~\ref{ch:upgrade}. 

\paragraph{Calling a \textit{Contract Account} to execute a logic.}
The last way of interaction of an EOA with Ethereum is sending a transactions by which calling a contract code to execute its logic. If the recipient (destination) of the transaction is a contract account, EVM will start executing its contract code automatically. To explain it better we split the process into two steps describe below:

\paragraph{Transaction Creation by user. }Suppose contract A has function ``setNumber'' to set a variable ``num'' that takes the new amount as input. If Alice decides to set a new number, for instance 3, to the num variable, she should send a transaction specify the recipient as contract A's address. Also transactions to a contract have another field named ``data'' in which the user indicates which function of the contract is going to call and what are the inputs for the function call. The data part of the transaction is also known as ``Call-Data'' field. Alice should declare that she is going to call ``setNumber'' function with input 3. Defining the target function in EVM is not by putting the name of function. 

EVM uses \textit{Function Selector} to recognize the functions which is the first four bytes of the Keccak-256 hash of the \textit{function signature}. The function signature is defined as the function name with the list of parameter types divided by a comma - no spaces are used. For instance, for our case the function signature is ``setNumber(uint)''. So, Alice calculates the function signature using this formula:

\begin{equation}
    Function Selector = Bytes4(keccak256("setNumber(uint)")) = 0x234a4ac2
\end{equation}

Now Alice has the function selector and can generate the call data of the transaction by putting together the function selector and the encoded inputs in the defined order. The transaction is created and should be signed by Alice and send to the Ethereum network.

\paragraph{Execution Process. } 
The next step is to define how EVM interpret and execute the transaction sent by Alice. EVM checks the recipient of the transaction and because it is the address of contract A, it will start executing the bytecode of contract A. Bytecodes in Ethereum first extract the first four bytes of call data of the transaction. Then checks that if the function selectors in the bytecode is match with the first four bytes of the call data. If a function selector found, it means that the user called that specific function of the contract (in our case, setNumber function of contract A). If EVM cannot find any function selector that matches the first four bytes of call data, then a function named \textbf{Fallback} function will be called. The Fallback function is a function defined in the high level languages (\eg Solidity) and supposed to be executed if EVM could not find function selector equal to the first four bytes of calldata or also if the calldata is empty (\ie sending Ether to the contract without function call). 

In each function, in the bytecode, first EVM will extract the inputs related to the function from calldata and then execute the logic of that function with the provided inputs.

Also it should be mentioned that a contract can also call a function of another contract providing the related function selector and inputs and the other processes are the same. This type of call are called \textbf{Internal Calls}. In literature it is also called \textbf{Messages} instead of transactions and will be discussed in detail in Section~\ref{sec:txVsMsg}.

There are other technical explanations needed about Ethereum that a reader should know for this thesis which we will describe below:

\subsection{Run-time bytecode vs. Contract Creation Code}
%run time and contract creation
In Ethereum the code that is sent to create contract (a.k.a \textbf{Contract Creation Code}), may be different with the code that is stored in the blockchain for that contract account (a.k.a \textbf{Run-time bytecode}). Run-time bytecode is the bytecode which is saved in the blockchain as the code of that specific contract account and each time the contract is called this code will be executed by EVM. But, Contract Creation code is the input data of the transaction by which a user or a contract tries to deploy a new contract. The Contract Creation code has a field, named \textit{init code}, which is responsible to: 1) make changes to the state of the contract (initializing the storage variables using a constructor), 2)put the run-time bytecode to the memory 3)put the length of the run-time bytecode in the memory 4)put the address in the memory where the run-time bytecode is saved in the stack 5)execute the \texttt{Return} opcode to push EVM to deploy the contract.\footnote{\url{https://leftasexercise.com/2021/09/05/a-deep-dive-into-solidity-contract-creation-and-the-init-code/}} 

So, the run-time bytecode could be completely different from the contract creation code. It will be discussed in the detail in Chapter~\ref{ch:upgrade} in Section~\ref{sec:metamorphic}.

\subsection{Storage Layout in EVM}
In Ethereum each contract account holds state in its own permanent storage. EVM uses an uncommon storage structure to store the storage state based on the variable types. It uses 32-bytes to 32-bytes key-value mapping to store the data which are zero initialized. Except dynamic arrays and mappings, the other variable types are stored in this structure contiguously one after another starting from slot 0. 

Mappings and dynamic arrays cannot be saved contiguously, because their size is unpredictable. So for dynamic arrays if the storage location after applying the rules ends up at slot P, the size of the array will be saved in this slot and the elements of the array will be saved contiguously starting from slot \textit{keccak256(p)}.

For mapping instead of dynamic array, zero will be saved in slot P. Also element of the mapping with key equal to K is stored in slot \textit{keccak256(h(K), p)} where h is keccak256 of the key value padded to 32 bytes.\textblue{cite the yellow paper.}

The storage variables are accessible On-Chain if there is a getter function inside the contract that gives the variable amount. Marking a variable as public is also give the opportunity to read the data On-Chain because Solidity compiler creates a getter function for all public variables. 

To read the data Off-chain, one need to have access to an Ethereum node which is discussed in further sections.


\subsection{Transaction vs. Message}\label{sec:txVsMsg}
We discussed Ethereum transactions in detail in the previous sections. A message is very similar to a transaction but it is produced by another contract instead of an EOA. Messages are the way that contracts calling each others' functions. A message is produces when a contract uses a \texttt{CALL}, \texttt{DELEGATECALL} or \texttt{STATICCALL} opcodes ,so a function from another contract will be executed. The main difference between \texttt{CALL} and \texttt{DELEGATECALL} opcodes is that by \texttt{CALL}ing another contract the storage layout of the the destination contract will be changed. But, \texttt{DELEGATECALL} another contract, keeps the contract context. It means that the storage layout of the caller contract will be changed instead of the destintion contract. It is analogues to copy pasting that specific function in the caller contract and running its logic inside the caller contract. There are risks regarding \texttt{DELEGATECALL} opcode and the fact that it keeps context such as \textit{function selector clashes} and \textit{storage layout clashes} which will be discussed in more details in Chapter~\ref{ch:upgrade}, Section~\ref{sec:delegatecall}.

Also it worths mentioning that \texttt{STATICCALL} act completely similar to \texttt{CALL} opcode, except it will be reverted if the message tries to change the state during the call. 
\footnote{\url{https://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html}}


%compiler ??!!

\subsection{Off-chain access to Blockchain data}

To have access to the data stored in Ethereum blockchain, one should have access to an ``Ethereum Node''. Ethereum node refer to running a piece of software called Ethereum client, which implemented the rules and specifications defined by Ethereum yellow paper \textblue{refer to yellow} to join and sync with Ethereum network to keep Ethereum network and data secure and safe.
\footnote{\url{https://ethereum.org/en/developers/docs/nodes-and-clients/}} 

There exists various implementations for Ethereum client in different languages (\eg Go, Rust, JavaScript,\etc). ``Geth'' is the most widely used Ethereum client written in Go. 
There are three different types of Ethereum nodes: Light node, Fast-sync and Archive full node.

\textit{Light node} stores the headers of the blocks and can have a limited verification such as state root verification. This type of clients are useful for devices that cannot store huge data.
\textit{Fast-sync Full node} stores all blockchain data, and can participate in new block generation. Also all past states can be derived from the full node but it takes time to grab the past data.
\textit{Archival Full node} not only stores all blockchain data, but also index them as well so that historical states can be accessed quickly on demand. In this thesis we call Archival Full node a
full node. 

An Ethereum full node has a JSON-RPC API that gives the user chance to use the methods implemented by the client and read the Ethereum data off-chain. Some of the methods that are used in this paper is listed below:

\begin{itemize}
    \item \emph{trace\_block}: Returns the transaction traces of all transactions in a specific block.
    \item \emph{eth\_getStorageAt}: Returns the value stored in a specific slot of a determined address. 
    \item \emph{eth\_getCode}: Returns the bytecode stored for the specific account address. If the address is EOA, it will return 0x0.
\end{itemize}

\section{Ethereum Use-cases}

In the previous section we mostly discussed the infrastructure of Ethereum and give the details about how Ethereum works under the hood and also how users can work with it. 
This section is mostly talk about the use-cases and nuances regarding them in Ethereum. Before explaining the use-cases one by one, we should shed light into one of the main obstacles that blockchain systems such as Ethereum has for developing different applications.


\paragraph{The Oracle Problem.}  

Smart contracts cannot access external resources (\eg a website or an online database) to fetch data that resides outside of the blockchain (\eg a price quote of an asset). External data needs to be relayed to smart contracts with an oracle. An \emph{oracle} is a bridge or gateway that connects the off-chain real world knowledge and the on-chain blockchain network. The `oracle problem'~\cite{linkOracleProblem} describes the limitation with which the types of applications that can execute solely within a fully decentralized, adversarial environment like Ethereum. Generally speaking, a public blockchain environment is chosen to avoid dependencies on a single (or a small set) of trusted parties. One of the first oracle implementations used a smart contract in the form of a database (\ie mapping\footnote{A Solidity \texttt{mapping} is simply a key-value database stored on a smart contract.}) and was updated by a trusted entity known as the \texttt{owner}. More modern oracle updating methods use consensus protocol with multiple data feeds or polling techniques based on the ``wisdom of the crowd''. The data reported by an oracle will always introduce a time lag from the data source and more complex polling methods generally imply longer latency.

\paragraph{Trusted Third Parties.} A natural question for smart contract developers to ask is: if you trust the oracle, why not just have it compute everything? There are a few answers to this question: (1) there may be benefits to minimizing the trust (\ie to just providing data instead of full execution), (2) there are widely trusted organizations and institutes---convincing one to operate an oracle service is a much lower technical ask than convincing one to operate a complete platform, and (3) if a data source becomes untrustworthy, it may require less effort to switch oracles than to redeploy the system. 

To mitigate the problem stated above, different solutions are developed to answer the oracle problem and provide data for the applications in Ethereum that needs the real-world data. We will discuss the problem and solution in detail in Chapter~\ref{ch:oracle}.

There are myriad of applications developed on top of Ethereum blockchain. Some of them uses the solutions describe in  Chapter~\ref{ch:oracle}, using one of them to address the oracle problem and bring real-world data on-chain. In later part of this section, we will explain the most favorable use-cases and applications on Ethereum.

\subsection{Stablecoins/Synthetic assets}

\paragraph{Synthetic Assets.} The red-black coin primitive can be generalized to produce black coins that match the price of any financial asset, not just a currency like the USD, simply by changing the price that the oracle references. For example, a black coin for one share of the company Apple (APPL) would use an ETH/APPL price feed (possibly constructed by bridging ETH/USD and APPL/USD prices) and otherwise be exactly the same. These black coins are ``synthetic assets'' because they expose the holder to the price movements of the asset but do not afford the holder any other benefits of holding the financial instrument (\eg shareholder votes or dividends for equities; physical delivery for futures; or the ability to settle a loan, or option contract on the asset). What a red coin represents in this example is less natural than for a stablecoin: it is a bet that ETH will increase in price faster than APPL.

\subsection{Decentralized Exchange (DeX)}

\subsection{Lending}

\subsection{Ethereum Name Service(ENS)}

\subsection{Derivatives}

\subsection{Decentralized Autonomous Organization (DAO)}

\subsection{Yield Farming}

\subsection{NFTs and Gaming}

\subsection{Privacy tools}

\subsection{Decentralized Identity}

\paragraph{Liquidations.} The worst-case scenario for a red-black coin is a decline in the value of ETH/USD. As a primitive, red-black coins simply force the holders to take on this risk. By contrast, liquidations are the main preventative mechanism used by full-fledged systems like Dai. Liquidations are controversial: many vault holders have lost ETH due to liquidations, they require special monitoring tools (\eg \texttt{DeFiSaver.com}), any analysis includes assumptions about how humans behave and how fast market actions can be taken, and maligned incentives (\eg return DAI for ETH when ETH/DAI is in decline) can lead to economic crises and de-leveraging spirals~\cite{GPH+20,KMM20}. Liquidations failed Dai on Ethereum's "Black Thursday" event in March 2020 and required a bail-out. In this paper, red-black coins can be thought of as "Dai without liquidations". Since liquidations have a downside, it is important to weigh these against what they contribute.
