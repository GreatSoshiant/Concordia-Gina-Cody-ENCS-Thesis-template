\chapter{Background}
\label{chap:background}
This chapter covers background information about Ethereum basics, details about Ethereum Virtual Machine (EVM), explanations on contract creation in Ethereum, and the way users interact with Ethereum network. Also, there is a section that briefly explains some use-cases and Dapps on Ethereum blockchain.
 
\section{Ethereum Background}

Ethereum is a state machine that is globally accessible and its Ethereum Virtual Machine, applies the changes to the state based on the rules defined for the Ethereum network. Ethereum is often described as ``world computer'' because anybody from anywhere can have access to Ethereum and use the stack of Ethereum and the EVM to execute their computations. 

Ethereum is the next generation of blockchains compared to Bitcoin. Bitcoin is just handling payments and some specific limited logic based on a limited scripting language which is called ``Bitcoin Scripting Language''. For instance, Bitcoin scripts cannot handle loops. But in Ethereum, EVM can handle more general and complex code named \textit{Smart Contracts}. EVM is quasi-Turing-complete state machine. It is ``quasi'' because computation in Ethereum is bounded to specific number of gas, which is a unit of measurement of computations and storage resources in Ethereum. 

Users can work with Ethereum blockchain by sending transactions to the network. They can just transfer Ether (or ETH), the native currency of Ethereum blockchain, or they can do their desired computations by executing smart contract functionalities in Ethereum. Users must pay the fee to work with Ethereum. This fee is calculated in gas, and it is based on the amount of computations and storage load on the Ethereum network and also network congestion.  

For more details about the basics of Ethereum, we refer Antonopoulos and Wood~\cite{antonopoulos2018mastering} (chapter one and two) to the readers who are eager to learn more about Ethereum.
In the further parts of this section, we explain the more detailed aspects of Ethereum Virtual Machine (EVM), Ethereum infrastructure, and Decentralized Applications (Dapps) running on top of Ethereum. 

Smart contracts (in Ethereum) are usually written in high-level programming languages such as Solidity and Vyper and compiled into a low-level EVM bytecodes using a compiler (\eg Solc). An EVM bytecode is a binary string that is interpretable by EVM. Then EVM bytecode will be deployed to the Ethereum blockchain.

To understand the process of deployment of a smart contract one should have familiarity with different types of accounts in Ethereum. There are two types of Ethereum accounts: \textit{Externally Owned Account (EOA)} and \textit{Contract Account}. 
EOA is an account that is controlled by a private key and keeps balance of Ethers that the account has and also a \textit{nonce}, which indicates the number of transactions sent by the account and acts like a counter to mitigate replay attacks. Any external actor can generate a random private key and use ECDSA encryption algorithm. Ethereum uses SECP-256k1 curve for ECDSA as described in the Ethereum yellow paper~\cite{wood2014ethereum}.
The EOA addresses can create new transactions, sign them with the private key related to the account and sent them to Ethereum network to be confirmed and recorded on the Ethereum blockchain. This transaction can:
\begin{enumerate}
    \item Send Ether to another EOA.
    \item Create a new \textit{Contract Account} by sending a bytecode.
    \item Call a \textit{Contract Account} to execute a logic.
\end{enumerate}

Each transaction type is explained below:

\paragraph{Sending Ether.} 
For sending Ether into another EOA account, the sender should specify the address which should be an EOA and not a contract account and also an amount to be sent.

\paragraph{Creating a new Contract Account.}
Creating a new \textit{Contract Account} is a bit tricky. The EOA should send a transaction containing the bytecode of the contract and setting the destination address to \emph{null}. Then EVM will create an address for the newly generated contract. The newly generated account (which is a contract account) keeps four fields: A \textit{nonce} which is similar to the nonce field in EOA accounts which keeps track of number of transactions created by that account; Ether balance which indicates number of Ether the account holds; \textit{Contract Code} which keeps the bytecode of the account which is executed each time a transaction calls the account; \textit{Contract Storage} which is a Merkle Patricia Tree data structure that maintains the data related to the contract account. Detailed explanation of the contract storage can be found in Section~\ref{sec:storagelayout}. 
The other important aspect of contract creation in Ethereum is how EVM generates the address for newly generated contract account. In EOA contract creation, EVM calculates the contract address by using the transaction sender's address and its nonce. The formula is show below:
\begin{equation}
    \label{eqn:create}
    Address = keccak256(rlp.encode(Sender Address, nonce))[12:]
\end{equation}
In this formula \textit{keccak256} is the \textit{sha3} hash used in Ethereum blockchain. Also \textit{RLP} (Recursive Length Prefix) encoding is used in Ethereum to encode arbitrary nested arrays of binary data, such as transactions data. Also at the end, EVM picks the last 20 bytes of the hash by removing the first twelve bytes of the hash.

In addition, contract accounts also can create a new contract account using two different EVM opcodes: \texttt{CREATE} and \texttt{CREATE2}. For transactions originated by a contract account and consist of these two opcodes, EVM will deterministically calculate the address for the new account and then create a contract account with the related four fields explained above. The whole process of contract creation is similar for these two opcodes, but the main difference is how EVM calculates the address for the contract account. For \texttt{CREATE} opcode the calculation formula is the same as Formula~\ref{eqn:create}, which EVM uses for EOA contract creation. But, for \texttt{CREATE2} opcode, EVM uses completely different formula to calculate it. In this type, EVM calculates the address by using sender's address and a bytecode that is sent to be deployed (a.k.a init code). Because the formula does not contain nonce and all other variables are predictable, the newly generated address in this type is \emph{Predictable}. The formula for contract address calculations using \texttt{CREATE2} is:

\begin{equation}
    \label{eqn:create2}
    Address = keccak256(0xff + senderAddress + salt + keccak256(init-code))[12:]    
\end{equation}

Based on the Formula~\ref{eqn:create2}, if the same sender address tries to deploy the same initialization code, the address will be the same. But, EVM does not permit to re-deploy a contract if there is still a contract account related to that address. But, there is a way to delete the previous contract account and then re-deploy the contract on the same address. If the contract contains a \texttt{SELFDESTRUCT} opcode, by calling it, the whole contract account along with its four field will be wiped out and so there is a chance to re-deploy the contract. The whole process is explained in detail in Chapter~\ref{ch:upgrade}. 

\paragraph{Calling a \textit{Contract Account} to execute a logic.}
The last way of interaction of an EOA with Ethereum is sending a transaction by which calling a contract code to execute its logic. If the recipient (destination) of the transaction is a contract account, EVM will start executing its contract code automatically. To explain it better we split the process into two steps describe below:

\paragraph{Transaction creation by user. }Suppose contract A has function ``setNumber'' to set a \textit{uint}\footnote{Unsigned Integer} variable ``num'' that takes the new amount as input. If Alice decides to assign a new number, for instance 3, to the num variable, she should send a transaction specify the recipient as contract A's address. Also transactions to a contract have another field named ``data'' in which the user indicates which function of the contract is going to be called and what are the inputs for the function call. The data part of the transaction is also known as ``Call-Data'' field. Alice should declare that she is going to call ``setNumber'' function with input 3. Defining the target function in EVM is not by putting the name of the function. 

EVM uses \textit{Function Selector} to recognize the functions which is the first four bytes of the Keccak-256 hash of the \textit{function signature}. The function signature is defined as the function name with the list of parameter types divided by a comma - no spaces are used. For instance, for our case the function signature is ``setNumber(uint)''. So, Alice calculates the function signature using this formula:

\begin{equation}
    Function Selector = Bytes4(keccak256(``setNumber(uint)'')) = 0x234a4ac2
\end{equation}

Now Alice has the function selector and can generate the call data of the transaction by putting together the function selector and the encoded inputs in the defined order. The transaction is created and should be signed by Alice and sends to the Ethereum network.

\paragraph{Execution Process. } 
The next step is to describe how EVM interpret and execute the transaction sent by Alice. EVM checks the recipient of the transaction and because it is the address of contract A, it will start executing the bytecode of contract A. EVM first extracts the first four bytes of call data of the transaction in case the transaction calls a contract. Then checks that if the function selectors in the bytecode matches with the first four bytes of the call data. If a function selector is found, it means that the user called that specific function of the contract (in our case, setNumber function of contract A). If EVM cannot find any function selector that matches the first four bytes of call data, then a function named \textbf{Fallback} function will be called. The Fallback function is a function defined in the high level languages (\eg Solidity) and supposed to be executed if EVM could not find function selector equal to the first four bytes of calldata or also if the calldata is empty (\ie sending Ether to the contract without function call). 

In each function, in the bytecode, first EVM will extract the inputs related to the function from calldata and then execute the logic of that function with the provided inputs.

Also it should be mentioned that a contract can also call a function of another contract providing the related function selector and inputs and the other processes are the same. This type of call are called \textbf{Internal Calls}. In literature, it is also called \textbf{Messages} instead of transactions and will be discussed in detail in Section~\ref{sec:txVsMsg}.

There are other technical explanations needed about Ethereum that a reader should know for this dissertation which we will describe below:

\subsection{Run-time Bytecode vs. Contract Creation Code}
%run time and contract creation
In Ethereum the code that is sent to create contract (a.k.a \textbf{Contract Creation Code}), may be different with the code that is stored in the blockchain for that contract account (a.k.a \textbf{Run-time bytecode}). Run-time bytecode is the bytecode which is saved in the blockchain as the code of that specific contract account and each time the contract is called, this code will be executed by EVM. But, Contract Creation code is the input data of the transaction by which a user or a contract tries to deploy a new contract. The Contract Creation code has a field, named \textit{init code}, which is responsible to: 1) make changes to the state of the contract (initializing the storage variables using a constructor), 2) put the run-time bytecode to the memory 3) put the length of the run-time bytecode in the memory 4) put the offset in the memory where the run-time bytecode is saved in the stack 5) execute the \texttt{Return} opcode to push EVM to deploy the contract.\footnote{\url{https://leftasexercise.com/2021/09/05/a-deep-dive-into-solidity-contract-creation-and-the-init-code/}} 

So, the run-time bytecode could be completely different from the contract creation code. It will be discussed in the detail in Chapter~\ref{ch:upgrade} in Section~\ref{sec:metamorphic}.

\subsection{Storage Layout in EVM} \label{sec:storagelayout}
In Ethereum each contract account holds state in its own permanent storage. EVM uses an uncommon storage structure to store the storage state based on the variable types. It uses 32-bytes to 32-bytes key-value mapping to store the data which are zero initialized. Except dynamic arrays and mappings, the other variable types are stored in this structure contiguously one after another starting from slot 0. 

Mappings and dynamic arrays cannot be saved contiguously, because their size is unpredictable. So for dynamic arrays if the storage location after applying the rules ends up at slot P, the size of the array will be saved in this slot and the elements of the array will be saved contiguously starting from slot \textit{keccak256(p)}.

For mapping instead of dynamic array, zero will be saved in slot P. Also element of the mapping with key equal to K is stored in slot \textit{keccak256(h(K), p)} where h is keccak256 of the key value padded to 32 bytes~\cite{wood2014ethereum}.

The storage variables are accessible on-chain if there is a getter function inside the contract that gives the variable amount. Marking a variable as public is also give the opportunity to read the data on-chain because Solidity compiler creates a getter function for all public variables. 

To read the data off-chain, one needs to have access to an Ethereum node which is discussed in Section~\ref{sec:nodes}.


\subsection{Transaction vs. Message}\label{sec:txVsMsg}
We discussed Ethereum transactions in detail in the previous sections. A message is very similar to a transaction but it is produced by another contract instead of an EOA. Messages are the way that contracts calling each others' functions. A message is produces when a contract uses a \texttt{CALL}, \texttt{DELEGATECALL} or \texttt{STATICCALL} opcodes. So, a function from another contract will be executed. The main difference between \texttt{CALL} and \texttt{DELEGATECALL} opcodes is that by \texttt{CALL}ing another contract the storage layout of the the destination contract will be changed. But, \texttt{DELEGATECALL}ing another contract, keeps the contract context. It means that the storage layout of the caller contract will be changed instead of the destintion contract. It is analogues to copy pasting that specific function in the caller contract and running its logic inside the caller contract. There are risks regarding \texttt{DELEGATECALL} opcode and the fact that it keeps context such as \textit{function selector clashes} and \textit{storage layout clashes} which will be discussed in more details in Chapter~\ref{ch:upgrade}, Section~\ref{sec:delegatecall}.

Also it worths mentioning that \texttt{STATICCALL} act completely similar to \texttt{CALL} opcode, except it will be reverted if the message tries to change the state during the call. 
\footnote{\url{https://ethdocs.org/en/latest/contracts-and-transactions/account-types-gas-and-transactions.html}}


%compiler ??!!

\subsection{Off-chain Access to the Blockchain Data}\label{sec:nodes}

To have access to the data stored in Ethereum blockchain, one should have access to an ``Ethereum Node''. Ethereum node refer to running a piece of software called Ethereum client, which implemented the rules and specifications defined by Ethereum yellow paper~\cite{wood2014ethereum} to join and sync with Ethereum network and to keep Ethereum network and data secure and safe.
\footnote{\url{https://ethereum.org/en/developers/docs/nodes-and-clients/}} 

There exists various implementations for Ethereum client in different languages (\eg Go, Rust, JavaScript,\etc). ``Geth'' is the most widely used Ethereum client written in Go. 
There are three different types of Ethereum nodes: Light node, Fast-sync and Archive full node.

\textit{Light node} stores the headers of the blocks and can have a limited verification such as state root verification. This type of clients are useful for devices that cannot store huge data.
\textit{Fast-sync Full node} stores all blockchain data, and can participate in new block generation. Also all past states can be derived from the full node but it takes time to grab the past data.
\textit{Archival Full node} not only stores all blockchain data, but also index them as well so that historical states can be accessed quickly on demand. In this thesis we call Archival Full node a
full node. 

An Ethereum full node has a JSON-RPC API that gives the user chance to use the methods implemented by the client and read the Ethereum data off-chain. Some of the methods that are used in this paper is listed below:

\begin{itemize}
    \item \emph{trace\_block}: Returns the transaction traces of all transactions in a specific block.
    \item \emph{eth\_getStorageAt}: Returns the value stored in a specific slot of a determined address. 
    \item \emph{eth\_getCode}: Returns the bytecode stored for the specific account address. If the address is EOA, it will return 0x0.
\end{itemize}

\section{Ethereum Use-cases}

In the previous section we mostly discussed the infrastructure of Ethereum and give the details about how Ethereum works under the hood and also how users can work with it. 
This section is mostly talk about the use-cases and nuances regarding them in Ethereum. Before explaining the use-cases one by one, we should shed light into one of the main obstacles that blockchain systems such as Ethereum has for developing different applications.


\paragraph{The Oracle Problem.}  

Smart contracts cannot access external resources (\eg a website or an online database) to fetch data that resides outside of the blockchain (\eg a price quote of an asset). External data needs to be relayed to smart contracts with an oracle. An \emph{oracle} is a bridge or gateway that connects the off-chain real world knowledge and the on-chain blockchain network. The `oracle problem'~\cite{linkOracleProblem} describes the limitation with which the types of applications that can execute solely within a fully decentralized, adversarial environment like Ethereum. Generally speaking, a public blockchain environment is chosen to avoid dependencies on a single (or a small set) of trusted parties. One of the first oracle implementations used a smart contract in the form of a database (\ie mapping\footnote{A Solidity \texttt{mapping} is simply a key-value database stored on a smart contract.}) and was updated by a trusted entity known as the \texttt{owner}. More modern oracle updating methods use consensus protocol with multiple data feeds or polling techniques based on the ``wisdom of the crowd''. The data reported by an oracle will always introduce a time lag from the data source and more complex polling methods generally imply longer latency.

\paragraph{Trusted Third Parties.} A natural question for smart contract developers to ask is: if you trust the oracle, why not just have it compute everything? There are a few answers to this question: (1) there may be benefits to minimizing the trust (\ie to just providing data instead of full execution), (2) there are widely trusted organizations and institutes---convincing one to operate an oracle service is a much lower technical ask than convincing one to operate a complete platform, and (3) if a data source becomes untrustworthy, it may require less effort to switch oracles than to redeploy the system. 

To mitigate the problem stated above, different solutions are developed to answer the oracle problem and provide data for the applications in Ethereum that needs the real-world data. We will discuss the problem and solution in detail in Chapter~\ref{ch:oracle}.

There are myriad of applications developed on top of Ethereum blockchain. Some of them uses the solutions describe in  Chapter~\ref{ch:oracle}, using one of them to address the oracle problem and bring real-world data on-chain. In later part of this section, we will explain the most favorable use-cases and applications on Ethereum.

\subsection{Stablecoins/Synthetic Assets}

A ``synthetic asset'' is an asset that tracks the price of another asset without holding the obligations of that asset. For instance, a synthetic asset of Apple share tracks the price of Apple share that does not receive dividends and not have any other obligations regarding the Apple share. This can be done by having the price of the asset provided by an oracle which is discussed above and some other ad-hoc mechanisms to stabilize the price of the asset that will be explained in Chapter~\ref{ch:dai}. An example Dapp that is providing synthetic assets is \textit{Synthetix}\footnote{\url{https://synthetix.io}}.

The asset can also be a currency (\eg USD) and in this case, it will be a stablecoin. A stablecoin is an asset that supposed to be peg to a currency such as USD. There are a myriad of stablecoin platform in Ethereum such as \dai which we will discuss in Chapter~\ref{ch:dai}

\subsection{Decentralized Exchange (DeX)}
Decentralized Exchanges (DeX) are platforms that helps users to exchange their assets without need of an intermediary. Two main types of Decentralized Exchanges are Automated Market Maker (AMM) and orderbook-based exchanges. 

In AMMs a party named Liquidity Provider (LP), creates pools for pairs of assets (could be more than two assets in a pool like Balancer protocol), and put liquidity on the pool. Users can exchange their assets in the pool. The smart contract will calculate the amount a user receive for a trade, using a mathematic formula based on the amount of liquidity in the pool and the amount user wants to exchange. Because the calculations and market making is done by smart contract automatically, this type of DeX is called Automated Market Maker. Uniswap\footnote{\url{https://uniswap.org}} is the most famous AMM running on Ethereum blockchain.

In traditional finance, majority of exchanges are orderbook-based. In orderbook-based exchanges, a user put her order to sell specific amount of asset A for specific amount of asset B. On the other hand, another user puts an order in reverse, to sell asset B for specific amount of asset A. The exchange will sort the orders of both sides and match the orders. This process is computational costly because of need of sorting and match making and not rational to be implemented on Ethereum mainnet because computations is expensive. But, there are platforms such as Loopring,\footnote{\url{https://loopring.org}} that implemented the whole process of order taking and match making off-chain, using a layer two solution named StarkEx,\footnote{\url{https://starkware.co/starkex/}} and put the results on-chain.

\subsection{Lending}
In lending platforms, users can lend and borrow crypto assets. There are pools of assets in these platforms that a user can lend those assets by depositing into the pools and can borrow against them. The borrowers are obliged to pay fees which is directly be paid to the lenders. Compound\footnote{\url{https://compound.finance}} and Aave\footnote{\url{https://aave.com}} are two most favorable lending Dapps on Ethereum at the time of writing the paper. 

\subsection{Ethereum Name Service (ENS)}
Ethereum Name Service (ENS)\footnote{\url{https://ens.domains}} is one of the most favorite Dapps in Ethereum that is not for financial purposes. ENS is a decentralized naming system that maps a human-readable names to Ethereum addresses. 
ENS recently adds support for crypto addresses other than Ethereum. Also users can launch their own websites using their ENS.

\subsection{Derivatives}
Derivatives are financial contracts that is based on value of another underlying asset or a basket of assets which include options, swaps, and future contracts. dYdX\footnote{\url{https://dydx.exchange}} is a decentralized trading platform that traders can go long or short up to 25x on specific assets like ETH, BTC, Link, \etc
Having 25x leverage position means that the user have exposure of 25x on the price changes means that if the user longs 25x, and if the price increase by 1\%, the user gains 25\%. If the user takes 25x short position and the price falls 1\% then the user gains 25\%.

Options are another type of derivatives in which the user has the right to buy\footnote{Call option} or sell\footnote{Put option} a specific amount of an asset, for a specific price.\footnote{strike price} Options has a expiration date: in American options style, one can exercise the contract before expiration date whenever they want but in European style the user can just exercise on the expiration date. Opyn\footnote{\url{https://www.opyn.co}} and Hegic\footnote{\url{https://www.hegic.co}} protocols are two options platform in Ethereum.


\subsection{Yield Farming}
Protocols like Compound give their native tokens to the active users. For instance, in Compound lenders and borrowers receive Comp token.\footnote{Native token of Compound} The aggregated fees collected by users in a year counted as Annual Percentage Yield (APY) which is completely related to the price of native token. There are different platforms that do almost the same logic, but with different APRs at the moment. This brings the idea to develop Dapps that calculate the best APR and use different strategies to maximize the APR of the user. Yearn\footnote{\url{https://yearn.finance}} is one of the leading Dapps that build different strategies to farm most benefit yields for the users. There are other yield farming Dapps such as Harvest finance\footnote{\url{https://harvest.finance}} or Pickle finance.\footnote{\url{https://www.pickle.finance}}

\subsection{Privacy Tools}
Ethereum blockchain do not ensure the anonymity and privacy on the main layer because of transparency. There are different solutions developed to bring privacy to the Ethereum transactions. One of the most favorite solutions is Tornado Cash.\footnote{\url{https://tornado.cash}} Tornado cash uses Zero-knowledge snarks to mix Ethers deposited into the contract and break the link between the deposited address and the withdrawn one. Another Dapp that uses Zero-knowledge to enable private transactions on Ethereum is Aztec protocol.\footnote{\url{https://aztec.network}}




\subsection{Liquidation} 
Liquidation is not a type of Dapp but because bunch of applications and use-cases described above have this process in common we put a section for it. It will be discussed in detail in Chapter~\ref{ch:dai}. Liquidation is used in stablecoins, synthetic assets, lending platforms, and derivatives. Liquidation happens when the value of the debt of a user exceeds a pre-specified portion of collateral provided by the user. So it means the user's collateral cannot back the debt in this situation. In traditional finance, the liquidation mostly managed by the broker or service provider. However, in DeFi, because of elimination of the intermediaries, the protocol incentivize the external actors, named \textit{Keepers}, to liquidate the position and top up the collateral or close buy the position.